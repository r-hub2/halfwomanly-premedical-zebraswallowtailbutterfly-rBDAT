<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="christian.vonderach@forst.bwl.de" />


<title>BDAT Implementation in R</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">BDAT Implementation in R</h1>
<h4 class="author"><a href="mailto:christian.vonderach@forst.bwl.de" class="email">christian.vonderach@forst.bwl.de</a></h4>
<h4 class="date">2020-10-08, 16:43:33</h4>



<div id="bdat-a-fortran-library-for-taper-curves" class="section level2">
<h2>BDAT: a Fortran library for taper curves</h2>
<p><em>BDAT</em> is a Fortran program library to estimate volume,
diameter, height, bark thickness and assortments of a specified tree.
Hence, it is a library about taper functions. It has been developed at
FVA-BW on request of BMELV for the first german national forest
inventory (BWI 1, 1987). Adjustements have been made for the BWI2
(2002). <em>BDATPro</em> is a version including these latest adjustments
but also an additionaly GUI. The latest version includes biomass
functions and form parameters for NFI3 (=BWI3). Here the latest version
was implemented.</p>
<p>Colloquially the library is called <strong>BDAT</strong>.</p>
<p>The Fortran library has been extensively used in several application,
of which the most important might be WEHAM (WaldEntwicklungs- and
HolzAufkommensModell: forest developement and timber stock prediction
model) but also in other forest inventories. At that time, R was not
emerged, yet, later direct calls to the Windows-DLL were used. With the
present R-package, the usage of BDAT in R was highly simplified, ported
to other operating systems (32bit and 64bit) and better documented.
There are some original documents on my gitlab repository about the
methodology and application, but all have been written in German.</p>
<p>The BDAT library is based on a spline representation of the taper
function of different tree species. A methodological improvement has
been made using B-Splines and mixed-modelling, see Kublin et al. 2013
and the R-package TapeR. Still, BDAT is in use and keeps being used
since the library offers more than just the taper form itself:
estimation of diameters, height, double bark thickness, volume of
sections defined by height and/or diameter, assortments given parameters
and all already parameterised for a whole bunch of tree species
including deciduous tree species with their complex tree crowns. It is
based on approximately 30.000 measured trees and studies on bark
thickness and tree crown volume.</p>
</div>
<div id="further-references" class="section level2">
<h2>further references</h2>
<p>Further references like BDAT Documentations, related articles and
reports can be found at <a href="https://gitlab.com/vochr/rbdat" class="uri">https://gitlab.com/vochr/rbdat</a> especially at <a href="https://gitlab.com/vochr/rbdat/-/tree/master/bdatdocs" class="uri">https://gitlab.com/vochr/rbdat/-/tree/master/bdatdocs</a>,
unfortunately these resources are all written in German.</p>
</div>
<div id="functions" class="section level2">
<h2>Functions</h2>
<p>The R-package contains all relevant functions from the
Fortran-library and uses vectorized evaluation. It is recommended to use
the get*-functions, but for convenience wrapper functions using the
names of the Fortan-subroutines are included so that older scripts can
easily be adapted to the use of the R-package.</p>
<p>Beside the core-functions (buildTree, getDiameter, getHeight,
getVolume, getAssortment, getBiomass, getBark, getForm and
getSpeciesCode) there is a plotting function.</p>
<div id="preliminary-note" class="section level3">
<h3>preliminary note</h3>
<p>The use of the BDAT Fortran functions requires the preparation of the
data to conform with what Fortran is expecting to come. Within this
R-Package, this is implemented in two ways: either one can prepare all
necessary variables within a list or data frame and pass it over to the
respective function via the <code>tree</code> parameter or one can pass
a tree definition into parameter <code>tree</code> of each function and
use the second parameter (i.e. <code>Dx</code>, <code>Hx</code>,
<code>AB</code> or <code>sort</code>, here called <code>vars</code>) to
hand over the required - function specific - information. In the first
case, the function returns one result for each row given. In the second
case, a cross join / cartesian product between <code>tree</code> and
<code>vars</code> is calculated. If <code>vars</code> is of size one,
the results is the same as in the first case. If the size of
<code>vars</code> is bigger than one, the functions return one value for
each given tree (e.g. 3) and element of <code>vars</code> (e.g. 4), in
the example this is 12. For functions returning a scalar, a matrix is
returned with <code>trees</code> given in rows and <code>vars</code>
given in columns (e.g. 3x4-matrix). The assortment function, usually
returning a data frame, still returns a data frame, but now the order
(and naming) of trees is different from the given input
<code>tree</code> parameter, since internally the tree object is now
expanded. Hence, the first tree is repeated (length-of-vars) number of
times, before the second tree is process and returned and so on.</p>
</div>
<div id="getting-started" class="section level3">
<h3>Getting started</h3>
<p>In BDAT, a tree is specified at its minimum by its species code, dbh
(diameter in breast height, i.e. 1.3m) and height. Implicitly, this
defines a second diameter in 30% of three height according to the
“Masse-Tafeln” (Volume-Tables) from Grundner und Schwappach (1921). For
the possibility of more precisely specifying taper form see further
below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(rBDAT)</span></code></pre></div>
<pre><code>## This is rBDAT 1.1.0</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">buildTree</span>(<span class="at">tree =</span> <span class="fu">list</span>(<span class="at">spp=</span><span class="dv">1</span>, <span class="at">D1=</span><span class="dv">30</span>, <span class="at">H=</span><span class="dv">27</span>))</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">str</span>(tree)</span></code></pre></div>
<pre><code>## Classes &#39;datBDAT&#39; and &#39;data.frame&#39;:  1 obs. of  6 variables:
##  $ spp: num 1
##  $ D1 : num 30
##  $ H  : num 27
##  $ H1 : num 1.3
##  $ D2 : num 0
##  $ H2 : num 0</code></pre>
<p>One can visualise the taper curve of a given tree using the
plot-function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">plot</span>(tree)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- -->
Here, the taper curve over bark (black) and under bark (grey) is
drawn.</p>
</div>
<div id="getting-bdat-species-code" class="section level3">
<h3>getting BDAT-species code</h3>
<p>BDAT has been parameterised for 36 tree species, more or less common
in Germany based on about 30.000 trees. These 36 tree species are index
and each posesses its own BDAT-species code. This code and the
respective species name (short and long format), english species name
and scientific name can be retrieved by the getSpeciesCode-function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">getSpeciesCode</span>()</span></code></pre></div>
<pre><code>##    ID kurz            lang short                   long            scientific
## 1   1   Fi          Fichte    NS        European spruce           Picea abies
## 2   2   SF    Sitka-Fichte    SS           Sitka spruce      Picea sitchensis
## 3   3   Ta           Tanne   ESF    European silver fir            Abies alba
## 4   4   KT    Kuestentanne    GF              Grand fir         Abies grandis
## 5   5  Kie          Kiefer    SP            Common pine      Pinus sylvestris
## 6   6   SK   Schwarzkiefer   AUP    European black pine           Pinus nigra
## 7   7   WK Weymouthskiefer   WEP          Weymouth pine         Pinus strobus
## 8   8   DG       Douglasie    DF            Douglas fir Pseudotsuga menziesii
## 9   9   La         Laerche   XLA                  larch            Larix spp.
## 10 10   EL  Europ. Laerche   ELA         European larch         Larix decidua
## 11 11   JL    Jap. Laerche   JLA         Japanese larch       Larix kaempferi
## 12 12   Th           Thuja    RC            Arbor vitae         Thuja plicata
## 13 13   Ts           Tsuga    WH         Canada hemlock    Tsuga heterophylla
## 14 14   SN             sNB    XC         other conifers     Coniferales trees
## 15 15   Bu           Buche    BE           Common beech       Fagus sylvatica
## 16 16   HB       Hainbuche   HBM               hornbeam      Carpinus betulus
## 17 17   Ei           Eiche    OK Common oak/sessile oak          Quercus spp.
## 18 18   RE        Roteiche   ROK                Red oak         Quercus rubra
## 19 19   Pa          Pappel   XPO                 poplar          Populus spp.
## 20 20   BP    Balsampappel   BPO          Balsam poplar   Populus balsamifera
## 21 21   Es           Esche    AH             Common ash    Fraxinus excelsior
## 22 22   Ah           Ahorn   XAH                  maple             Acer spp.
## 23 23   BA       Bergahorn    SY         sycamore maple   Acer pseudoplatanus
## 24 24   SA      Spitzahorn   NOM            plane maple      Acer platanoides
## 25 25   FA       Feldahorn    FM            field maple        Acer campestre
## 26 26   Bi           Birke   XBI                  birch           Betula spp.
## 27 27   Li           Linde    LI              lime tree            Tilia spp.
## 28 28   Er            Erle    AR                  alder            Alnus spp.
## 29 29  Kir         Kirsche   WCH                 cherry          Prunus avium
## 30 30   Ul            Ulme    EM                    elm            Ulmus spp.
## 31 31   Ro         Robinie    BL         Common robinia  Robinia pseudoacacia
## 32 32   El        Elsbeere   WST      Wild service tree     Sorbus torminalis
## 33 33   Ka        Kastanie    SC      European chestnut       Castanea sativa
## 34 34   We           Weide   XWL                 willow            Salix spp.
## 35 35   LB             sLB    XB      other broadleaves   Magnoliopsida trees
## 36 36   VB      Vogelbeere   ROW            rowan berry      Sorbus aucuparia</code></pre>
<p>If the function is called without any parameter, a data.frame is
returned holding the information which can be retrieved. One can
alternatively specify the type of <code>input</code> and
<code>output</code>. <code>Input</code> must be one of the data entries,
<code>output</code> must be one of the column names.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">getSpeciesCode</span>(<span class="dv">1</span>)</span></code></pre></div>
<pre><code>##   ID kurz   lang short            long  scientific
## 1  1   Fi Fichte    NS European spruce Picea abies</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">getSpeciesCode</span>(<span class="st">&quot;Fi&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">getSpeciesCode</span>(<span class="st">&quot;NS&quot;</span>) <span class="co"># english abbreviation of Norway spruce</span></span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">getSpeciesCode</span>(<span class="dv">1</span>, <span class="st">&quot;scientific&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;Picea abies&quot;</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">getSpeciesCode</span>(<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">36</span>), <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>##  [1] &quot;NS&quot;  &quot;SS&quot;  &quot;ESF&quot; &quot;GF&quot;  &quot;SP&quot;  &quot;AUP&quot; &quot;WEP&quot; &quot;DF&quot;  &quot;XLA&quot; &quot;ELA&quot; &quot;JLA&quot; &quot;RC&quot; 
## [13] &quot;WH&quot;  &quot;XC&quot;  &quot;BE&quot;  &quot;HBM&quot; &quot;OK&quot;  &quot;ROK&quot; &quot;XPO&quot; &quot;BPO&quot; &quot;AH&quot;  &quot;XAH&quot; &quot;SY&quot;  &quot;NOM&quot;
## [25] &quot;FM&quot;  &quot;XBI&quot; &quot;LI&quot;  &quot;AR&quot;  &quot;WCH&quot; &quot;EM&quot;  &quot;BL&quot;  &quot;WST&quot; &quot;SC&quot;  &quot;XWL&quot; &quot;XB&quot;  &quot;ROW&quot;</code></pre>
</div>
<div id="getting-diameter-in-given-height" class="section level3">
<h3>getting diameter in given height</h3>
<p>The taper functions specify a curve being a function of height within
tree and returns the respective diameter. Hence, one can evalutate this
function at a given height and receive the diameter. There are fortran
functions to return either diameter over bark and diameter under bark,
but this package binds these functions together and uses a boolean
parameter to switch between both.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">getDiameter</span>(tree, <span class="at">Hx =</span> <span class="fl">1.3</span>) <span class="co"># return dbh</span></span></code></pre></div>
<pre><code>## [1] 30</code></pre>
<p>As a default, diameter over bark is returned, but this can easily be
changed:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="fu">getDiameter</span>(tree, <span class="at">Hx =</span> <span class="fl">1.3</span>, <span class="at">bark =</span> <span class="cn">FALSE</span>) <span class="co"># return d.u.b. at 1.3m</span></span></code></pre></div>
<pre><code>## [1] 28.40971</code></pre>
<p>It is possible to request diameter in several heights at once:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="fu">getDiameter</span>(tree, <span class="at">Hx =</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>))</span></code></pre></div>
<pre><code>##  [1] 31.14922 28.44761 27.57622 26.92106 26.32229 25.76090 25.21790 24.67427
##  [9] 24.11234 23.52139</code></pre>
<p>Using this kind of call to the functions, <code>Hx</code> is
evaluated for each given tree separately:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>tree2 <span class="ot">&lt;-</span> <span class="fu">buildTree</span>(<span class="fu">list</span>(<span class="at">spp=</span><span class="dv">1</span>, <span class="at">D1=</span><span class="fu">c</span>(<span class="dv">30</span>, <span class="dv">35</span>), <span class="at">H=</span><span class="dv">27</span>))</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="fu">getDiameter</span>(tree2, <span class="at">Hx =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span></code></pre></div>
<pre><code>##          [,1]     [,2]
## [1,] 31.14922 28.44761
## [2,] 36.54927 32.92451</code></pre>
<p>Here, a matrix is returned with one row per tree and one column per
requested Hx.</p>
<p>An alternative way is specifying <code>Hx</code> directly inside the
tree-object:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>tree2 <span class="ot">&lt;-</span> <span class="fu">buildTree</span>(<span class="fu">list</span>(<span class="at">spp=</span><span class="dv">1</span>, <span class="at">D1=</span><span class="fu">c</span>(<span class="dv">30</span>, <span class="dv">35</span>), <span class="at">H=</span><span class="dv">27</span>, <span class="at">Hx=</span><span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)))</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>tree2</span></code></pre></div>
<pre><code>##   spp D1  H Hx  H1 D2 H2
## 1   1 30 27  1 1.3  0  0
## 2   1 35 27  2 1.3  0  0</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="fu">getDiameter</span>(tree2)</span></code></pre></div>
<pre><code>## [1] 31.14922 32.92451</code></pre>
<p>Here, tree2 consists of 2 rows, because the give list is internally
transformed into a data frame (common rules for building data.frames
apply). Finally, the object is evaluated row-wise. Because
<code>Hx</code> is already given, the parameter <code>Hx</code> can be
left empty.</p>
</div>
<div id="getting-double-bark-thickness" class="section level3">
<h3>getting double bark thickness</h3>
<p>Double bark thickness is that part of a diameter over bark, which is
considered to consist of bark tissue. The relation between wood and bark
with respect to diameter can be expressed as {double bark thickness} +
{diameter under bark} = {diameter over bark}. The implemented functions
originate from the works of Altherr et al. (1974, 1975, 1976, 1978 and
1979).</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>dub <span class="ot">&lt;-</span> <span class="fu">getDiameter</span>(tree, <span class="at">Hx=</span><span class="fl">1.3</span>, <span class="at">bark =</span> <span class="cn">FALSE</span>)</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>dob <span class="ot">&lt;-</span> <span class="fu">getDiameter</span>(tree, <span class="at">Hx=</span><span class="fl">1.3</span>, <span class="at">bark =</span> <span class="cn">TRUE</span>)</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>dbt <span class="ot">&lt;-</span> <span class="fu">getBark</span>(tree, <span class="at">Hx=</span><span class="fl">1.3</span>)</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>dub <span class="sc">+</span> dbt <span class="sc">==</span> dob</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Again, it is possible to either include parameter <code>Hx</code>
into the tree-object or pass it separately. In the second case, an
matrix is returned if Hx is longer than one.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">getBark</span>(tree2, <span class="at">Hx =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)</span></code></pre></div>
<pre><code>##          [,1]     [,2]     [,3]     [,4]     [,5]
## [1,] 1.636124 1.527308 1.491416 1.464177 1.439089
## [2,] 1.842470 1.705602 1.661812 1.629562 1.600471</code></pre>
</div>
<div id="getting-height-for-given-diameter" class="section level3">
<h3>getting height for given diameter</h3>
<p>The diameter-height-relation from above, where we evaluated the
function for a given height-value, can also be evaluated for a given
diameter. The internal function is an iterative procedure to determine
height. Diameter can be specified over and under bark. Default is bark =
TRUE.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">getHeight</span>(tree, <span class="at">Dx=</span><span class="dv">30</span>) <span class="co"># height of diameter over bark</span></span></code></pre></div>
<pre><code>## [1] 1.3</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="fu">getHeight</span>(tree, <span class="at">Dx=</span><span class="dv">30</span>, <span class="at">bark =</span> <span class="cn">FALSE</span>) <span class="co"># height of diameter under bark == 30</span></span></code></pre></div>
<pre><code>## [1] 0.8916153</code></pre>
<p>Again, it is possible to vary passing of the
<code>Dx</code>-parameter: it can take one or several values, but can
also be included to the tree parameter. In the first case, a cross join
/ cartesian product between <code>tree</code> and <code>Dx</code> is
created, in the second case the <code>tree</code> object is processed
<em>as is</em>.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="fu">getHeight</span>(tree2, <span class="at">Dx=</span><span class="fu">c</span>(<span class="dv">30</span>, <span class="dv">20</span>, <span class="dv">10</span>)) <span class="co"># returns value in meters</span></span></code></pre></div>
<pre><code>##          [,1]     [,2]     [,3]
## [1,] 1.300000 14.82080 22.65465
## [2,] 5.370549 17.27376 23.05898</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>tree2<span class="sc">$</span>Dx <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">30</span>, <span class="dv">20</span>)</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a><span class="fu">getHeight</span>(tree2)</span></code></pre></div>
<pre><code>## [1]  1.30000 17.27376</code></pre>
<p>As one can see, in the first case a matrix with one row per tree and
one column per <code>Dx</code> is returned and in the second call, a
vector with one element for each row in <code>tree2</code>.</p>
</div>
<div id="getting-volume" class="section level3">
<h3>getting volume</h3>
<p>The maybe most interesting function is the one returning volume. The
function includes a switch to return volume with (the default) or
without bark volume as well. Volume is calculated using
middiameter-formula (in Germany called “Huber’sche Formel”) from
2m-sections (default), but section lengths can be varied. Additionally,
it is necessary to specify the section for which volume is required.
This can be done either using diameters or heights, or a mixture of
both. If parameter <code>AB</code> is not given, i.e. NULL, then the
function assumes coarse wood volume over bark is required (i.e. from
forest floor up to diameter over bark of 7cm):</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="fu">getVolume</span>(tree) <span class="co"># get coarse wood, which is the same as next line</span></span></code></pre></div>
<pre><code>## [1] 0.9168622</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">getVolume</span>(tree, <span class="at">AB =</span> <span class="fu">list</span>(<span class="at">A=</span><span class="dv">0</span>, <span class="at">B=</span><span class="dv">7</span>), <span class="at">iAB=</span><span class="fu">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;Dob&quot;</span>), <span class="at">bark =</span> T) </span></code></pre></div>
<pre><code>## [1] 0.9168622</code></pre>
<p>One can precisely specify the section for which volume under or over
bark is required:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="co"># volume including bark between height 1m and 2m</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="fu">getVolume</span>(tree2, <span class="at">AB=</span><span class="fu">list</span>(<span class="at">A=</span><span class="dv">1</span>, <span class="at">B=</span><span class="dv">2</span>)) </span></code></pre></div>
<pre><code>## [1] 0.06184182 0.08197092</code></pre>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="co"># volume excluding bark between 30 and 7cm in diameter over bark</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a><span class="fu">getVolume</span>(tree2, <span class="at">AB=</span><span class="fu">list</span>(<span class="at">A=</span><span class="dv">30</span>, <span class="at">B=</span><span class="dv">7</span>), <span class="at">iAB=</span><span class="st">&quot;dob&quot;</span>, <span class="at">bark =</span> F) </span></code></pre></div>
<pre><code>## [1] 0.7153726 0.6583801</code></pre>
<p>The section length for which middiameter-formula is applied is 2m as
a default. It is possible to change that behaviour by setting parameter
<code>sl</code> inside the <code>AB</code>-argument:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="co"># again: coarse wood volume</span></span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a><span class="fu">getVolume</span>(tree) </span></code></pre></div>
<pre><code>## [1] 0.9168622</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="co"># identical</span></span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a><span class="fu">getVolume</span>(tree, <span class="at">AB=</span><span class="fu">list</span>(<span class="at">A=</span><span class="fl">0.27</span>, <span class="at">B=</span><span class="dv">7</span>, <span class="at">sl=</span><span class="dv">2</span>), <span class="at">iAB=</span><span class="fu">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;Dob&quot;</span>), <span class="at">bark=</span>F) </span></code></pre></div>
<pre><code>## [1] 0.7892534</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="co"># using sl=0.1, that is section length for volume calculation set to be 0.1m</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a><span class="fu">getVolume</span>(tree, <span class="at">AB=</span><span class="fu">list</span>(<span class="at">A=</span><span class="fl">0.27</span>, <span class="at">B=</span><span class="dv">7</span>, <span class="at">sl=</span><span class="fl">0.1</span>), <span class="at">iAB=</span><span class="fu">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;Dob&quot;</span>), <span class="at">bark=</span>F) </span></code></pre></div>
<pre><code>## [1] 0.7971188</code></pre>
<p>If one wants to get the volume for several sections of a tree, one
could either build a suited data.frame on its own, repeating the tree
attributes and adjusting the <code>A</code>and <code>B</code> values as
needed. The more elegant way is to let the functions do that work for
you. In the easiest case, we saw that already in the example above,
specifying one tree and one section, where the function returns exactly
one volume. Internally, the <code>AB</code> data is merged to the tree
data by a cross join (or cartesion product), hence we can make use of
that behaviour by defining several sections at once:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="fu">getVolume</span>(tree, <span class="at">AB=</span><span class="fu">list</span>(<span class="at">A=</span><span class="dv">0</span><span class="sc">:</span><span class="dv">9</span>, <span class="at">B=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>))</span></code></pre></div>
<pre><code>##  [1] 0.09056835 0.06184182 0.06128590 0.05816483 0.05563769 0.05319688
##  [7] 0.05102357 0.04886994 0.04674566 0.04458112</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="fu">getVolume</span>(<span class="at">tree =</span> tree2, <span class="at">AB=</span><span class="fu">list</span>(<span class="at">A=</span><span class="dv">0</span><span class="sc">:</span><span class="dv">9</span>, <span class="at">B=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>))</span></code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]       [,4]       [,5]       [,6]
## [1,] 0.09056835 0.06184182 0.06128590 0.05816483 0.05563769 0.05319688
## [2,] 0.12786366 0.08197092 0.08171326 0.07714033 0.07358742 0.07018656
##            [,7]       [,8]       [,9]      [,10]
## [1,] 0.05102357 0.04886994 0.04674566 0.04458112
## [2,] 0.06725162 0.06435400 0.06151795 0.05862010</code></pre>
</div>
<div id="getting-biomass" class="section level3">
<h3>getting biomass</h3>
<p>Beside getting volume section information, there is a function to get
total aboveground biomass. These biomass-functions were fitted
independently of the parameterisation of BDAT and were developed in
preparation of the german NFI3. These functions are based on 983
analysed trees of a subset of species only. The other species are either
fit at a synthetical data set or in worst case subsumed to other
species. These functions are the official ones used during reporting of
results of the NFI3.</p>
<p>The call is identical to the already shown pattern:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="fu">getBiomass</span>(tree)</span></code></pre></div>
<pre><code>## [1] 406.1523</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="fu">getBiomass</span>(<span class="fu">list</span>(<span class="at">spp=</span><span class="dv">1</span>, <span class="at">D1=</span><span class="dv">30</span>, <span class="at">H=</span><span class="dv">27</span>, <span class="at">D2=</span><span class="fu">c</span>(<span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">25</span>))) </span></code></pre></div>
<pre><code>## [1] 350.5038 375.2445 400.5624</code></pre>
</div>
<div id="getting-assortments" class="section level3">
<h3>getting assortments</h3>
<p>One very nice feature of the BDAT program library is its ability to
use the presented functions to simulate roundwoods from given trees. For
that purpose a separate function was written, which is called via
<code>getAssortment()</code>. Similarly to other functions, it requires
data of one or more trees and optionally parameters to control the
sorting process. There are quite a few parameters to be specified. It’s
easiest to show that using some examples:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">getAssortment</span>(tree2) <span class="co"># using standard assortment parameters</span></span></code></pre></div>
<pre><code>##    tree No Sort height    length      midD      topD        Vol
## 1     1  1    X   0.00  0.000000  0.000000  0.000000 0.00000000
## 2     1  2  Sth   0.27 20.000000 21.250875 12.429831 0.70937115
## 3     1  3   Ab   0.00  0.000000  0.000000  0.000000 0.00000000
## 4     1  4  Ind  20.47  1.000000 11.460602 10.725959 0.01031584
## 5     1  5 nvDh  21.47  2.717499  8.529173  5.998856 0.01552648
## 6     2  1    X   0.00  0.000000  0.000000  0.000000 0.00000000
## 7     2  2  Sth   0.27 20.000000 24.499969 13.956373 0.94286811
## 8     2  3   Ab   0.00  0.000000  0.000000  0.000000 0.00000000
## 9     2  4  Ind  20.47  1.000000 12.778620 11.893189 0.01282501
## 10    2  5 nvDh  21.47  2.904999  9.106683  5.990857 0.01892153</code></pre>
<p>By default, a data.frame is returned with one row for each tree and
roundwood piece. It keeps information about the roundwood foot position
inside the stem, its length (without add-on), mid-diameter under bark
(midD), top-diameter under bark (topD) and the respective volume under
bark. The standard assortments comprise stem-wood (Sth), second length
stem wood (Ab, after optionally specified cutting diameter for Sth or
after transportation-cut, i.e. 20m), industrial roundwood (Ind) and
residual coarse wood (nvDh, between cutting diameter for Ind and 7cm
over bark). Assortment X is unusuable wood at the stem foot.</p>
<p>If one is interested in raw BDAT return, one can specify
<code>value=&#39;raw&#39;</code>:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="fu">getAssortment</span>(tree2, <span class="at">value =</span> <span class="st">&quot;raw&quot;</span>) <span class="co"># usually of little interest...</span></span></code></pre></div>
<pre><code>## $n
## [1] 2
## 
## $BDATArtNr
## [1] 1 1
## 
## $D1
## [1] 30 35
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $H1
## [1] 1.3 1.3
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $D2
## [1] 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $H2
## [1] 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $H
## [1] 27 27
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $lX
## [1] 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $Hkz
## [1] 0 0
## 
## $Skz
## [1] 0 0
## 
## $Az
## [1] 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $Hsh
## [1] 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $Zsh
## [1] 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $Zab
## [1] 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $Sokz
## [1] 1 1
## 
## $Skl
##  [1] 0 0 2 0 0 0 0 0 2 0 0 0
## 
## $Vol
##  [1] 0.91686225 0.00000000 0.70937115 0.00000000 0.01031584 0.01552648
##  [7] 0.18164879 1.21056700 0.00000000 0.94286811 0.00000000 0.01282501
## [13] 0.01892153 0.23595232
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $LDSort
##  [1]  0.000000  0.000000  0.000000  0.000000  0.270000 20.000000 21.250875
##  [8] 12.429831  0.000000  0.000000  0.000000  0.000000 20.470001  1.000000
## [15] 11.460602 10.725959 21.470001  2.717499  8.529173  5.998856  0.000000
## [22]  0.000000  0.000000  0.000000  0.270000 20.000000 24.499969 13.956373
## [29]  0.000000  0.000000  0.000000  0.000000 20.470001  1.000000 12.778620
## [36] 11.893189 21.470001  2.904999  9.106683  5.990857
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $BHD
## [1] 30 35
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $Ifeh
## [1] 0 0
## 
## $FixLngDef
## [1] 0 0 0 0 0 0 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $NMaxFixLng
## [1] 0 0
## 
## $FixLng
##   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
##  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
##  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [112] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [149] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [186] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [223] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [260] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [297] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [334] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## attr(,&quot;Csingle&quot;)
## [1] TRUE
## 
## $NFixLng
## [1] 0 0</code></pre>
<p>Other options are also available like ‘Vol’ (Volume), ‘Skl’
(Stärkeklassen, i.e. diameter classes), ‘Fix’ (fixed length assortments,
if specified) and ‘LDSort’ (an added feature w.r.t. the original BDAT
Fortran code, keeping length and diameter of the assortments, which was
missing in the original BDAT library, hence only available in rBDAT!),
which return a subset of the raw BDAT return value. The default is
‘merge’ which produces an aggregated data.frame of relevant information
about the roundwoods produced for each tree.</p>
<p>As said before, assortment rules can be specified using several
parameters, which in detail are given in the help file. Some examples
follow:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="fu">getAssortment</span>(tree, <span class="at">sort=</span><span class="fu">list</span>(<span class="at">Az=</span><span class="dv">15</span>)) <span class="co"># minimum diameter o.b. for assortments</span></span></code></pre></div>
<pre><code>##   tree No Sort height    length     midD      topD        Vol
## 1    1  1    X  0.000  0.000000  0.00000  0.000000 0.00000000
## 2    1  2  Sth  0.270 19.100000 21.51180 13.584801 0.69418710
## 3    1  3   Ab  0.000  0.000000  0.00000  0.000000 0.00000000
## 4    1  4  Ind  0.000  0.000000  0.00000  0.000000 0.00000000
## 5    1  5 nvDh 19.561  4.626499 10.10419  5.998856 0.03709757</code></pre>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">getAssortment</span>(tree, <span class="at">sort=</span><span class="fu">list</span>(<span class="at">Az=</span><span class="dv">15</span>, <span class="at">Hsh=</span><span class="dv">10</span>)) <span class="co"># Hsh= max. height of sawlog quality</span></span></code></pre></div>
<pre><code>## Warning in getAssortment.datBDAT(tree, sort = list(Az = 15, Hsh = 10)): error indication in subroutine BDAT20:
## tree 1: Top-shafted coniferous tree with positive stem height: Skz = 0|1 and Hsh &gt; 0; spp &lt; 15</code></pre>
<pre><code>##   tree No Sort height length midD topD Vol
## 1    1  1    X     NA     NA   NA   NA  NA
## 2    1  2  Sth     NA     NA   NA   NA  NA
## 3    1  3   Ab     NA     NA   NA   NA  NA
## 4    1  4  Ind     NA     NA   NA   NA  NA
## 5    1  5 nvDh     NA     NA   NA   NA  NA</code></pre>
<p>Additionally one can specify a fixed length assortment at stem foot,
which is cut before sawlogs.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a><span class="do">## fixN = number of roundwood pieces</span></span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a><span class="do">## fixL = length of roundwood pieces in m</span></span>
<span id="cb73-3"><a href="#cb73-3" tabindex="-1"></a><span class="do">## fixA = absolute length addition (good for measure) in cm</span></span>
<span id="cb73-4"><a href="#cb73-4" tabindex="-1"></a><span class="do">## fixR = relative length addition in %</span></span>
<span id="cb73-5"><a href="#cb73-5" tabindex="-1"></a><span class="do">## fixZ = minimum cutting diameter for this assortment (Z=Zopf) in cm</span></span>
<span id="cb73-6"><a href="#cb73-6" tabindex="-1"></a><span class="fu">getAssortment</span>(tree, <span class="at">sort=</span><span class="fu">list</span>(<span class="at">Az=</span><span class="dv">15</span>, <span class="at">fixN=</span><span class="dv">2</span>, <span class="at">fixL=</span><span class="dv">4</span>, <span class="at">fixA=</span><span class="dv">10</span>, <span class="at">fixZ=</span><span class="dv">20</span>)) </span></code></pre></div>
<pre><code>##   tree No  Sort height  length     midD     topD       Vol
## 1    1  1     X  0.270  8.2000 24.48928 22.25621 0.0000000
## 2    1  2   Sth 16.670 10.9000 19.04127  0.00000 0.3103904
## 3    1  3    Ab  0.000  0.0000  0.00000  0.00000 0.0000000
## 4    1  4   Ind  0.000  0.0000  0.00000  0.00000 0.0000000
## 5    1  5  nvDh 27.679  4.7085 10.16843  0.00000 0.0382367
## 6    1  6 Fix01  0.270  4.0000 25.86922 24.54741 0.2102405
## 7    1  7 Fix02  4.370  4.0000 23.40202 22.30943 0.1720507</code></pre>
<p>In case the considered tree exhibits rotten/decaying wood at stem
foot, this can also be specified (in german termed X-Holz):</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a><span class="fu">getAssortment</span>(tree, <span class="at">sort=</span><span class="fu">list</span>(<span class="at">lX=</span><span class="fl">1.4</span>)) <span class="co"># remove 1.4m from stump upwards</span></span></code></pre></div>
<pre><code>##   tree No Sort height    length      midD      topD        Vol
## 1    1  1    X   0.27  1.400000 28.892862 26.715826 0.09179077
## 2    1  2  Sth   1.67 20.000000 20.387375 10.421552 0.65289372
## 3    1  3   Ab   0.00  0.000000  0.000000  0.000000 0.00000000
## 4    1  4  Ind   0.00  0.000000  0.000000  0.000000 0.00000000
## 5    1  5 nvDh  21.87  2.317499  8.178885  5.998856 0.01217580</code></pre>
<p>Additionally, one can plot the taper curve and include the
assortments:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a>assort <span class="ot">&lt;-</span> <span class="fu">getAssortment</span>(tree, <span class="at">sort=</span><span class="fu">list</span>(<span class="at">Az=</span><span class="dv">15</span>, <span class="at">fixN=</span><span class="dv">2</span>, <span class="at">fixL=</span><span class="dv">4</span>, <span class="at">fixA=</span><span class="dv">10</span>, <span class="at">fixZ=</span><span class="dv">20</span>))</span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a><span class="fu">plot</span>(tree, <span class="at">assort=</span>assort)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
<div id="using-more-than-one-assortment-specification" class="section level4">
<h4>using more than one assortment specification</h4>
<p><code>buildTree</code> uses the parameters <code>tree</code> and
<code>vars</code> which are merged by a cross join / cartesian product.
Hence, if assortment specifications are extended to a length bigger one,
the function should return an estimated assortment for each tree and
specified assortment. Let’s check that:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="fu">getAssortment</span>(tree, <span class="at">sort =</span> <span class="fu">list</span>(<span class="at">Az=</span><span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">7</span>)))</span></code></pre></div>
<pre><code>##    tree No Sort height     length      midD      topD         Vol
## 1     1  1    X   0.00  0.0000000  0.000000  0.000000 0.000000000
## 2     1  2  Sth   0.27 20.0000000 21.250875 12.429831 0.709371150
## 3     1  3   Ab   0.00  0.0000000  0.000000  0.000000 0.000000000
## 4     1  4  Ind  20.47  2.0000000 10.725959  9.139494 0.018071413
## 5     1  5 nvDh  22.47  1.7174988  7.639552  5.998856 0.007872671
## 6     2  1    X   0.00  0.0000000  0.000000  0.000000 0.000000000
## 7     2  2  Sth   0.27 20.0000000 21.250875 12.429831 0.709371150
## 8     2  3   Ab   0.00  0.0000000  0.000000  0.000000 0.000000000
## 9     2  4  Ind  20.47  3.0000000  9.953113  7.379699 0.023341509
## 10    2  5 nvDh  23.47  0.7174988  6.702212  5.998856 0.002531322</code></pre>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a><span class="fu">getAssortment</span>(tree2, <span class="at">sort =</span> <span class="fu">list</span>(<span class="at">Az=</span><span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">7</span>)))</span></code></pre></div>
<pre><code>##    tree No Sort height     length      midD      topD         Vol
## 1     1  1    X   0.00  0.0000000  0.000000  0.000000 0.000000000
## 2     1  2  Sth   0.27 20.0000000 21.250875 12.429831 0.709371150
## 3     1  3   Ab   0.00  0.0000000  0.000000  0.000000 0.000000000
## 4     1  4  Ind  20.47  2.0000000 10.725959  9.139494 0.018071413
## 5     1  5 nvDh  22.47  1.7174988  7.639552  5.998856 0.007872671
## 6     2  1    X   0.00  0.0000000  0.000000  0.000000 0.000000000
## 7     2  2  Sth   0.27 20.0000000 24.499969 13.956373 0.942868114
## 8     2  3   Ab   0.00  0.0000000  0.000000  0.000000 0.000000000
## 9     2  4  Ind  20.47  2.0000000 11.893189 10.009459 0.022218592
## 10    2  5 nvDh  22.47  1.9049988  8.071947  5.990857 0.009748576
## 11    3  1    X   0.00  0.0000000  0.000000  0.000000 0.000000000
## 12    3  2  Sth   0.27 20.0000000 21.250875 12.429831 0.709371150
## 13    3  3   Ab   0.00  0.0000000  0.000000  0.000000 0.000000000
## 14    3  4  Ind  20.47  3.0000000  9.953113  7.379699 0.023341509
## 15    3  5 nvDh  23.47  0.7174988  6.702212  5.998856 0.002531322
## 16    4  1    X   0.00  0.0000000  0.000000  0.000000 0.000000000
## 17    4  2  Sth   0.27 20.0000000 24.499969 13.956373 0.942868114
## 18    4  3   Ab   0.00  0.0000000  0.000000  0.000000 0.000000000
## 19    4  4  Ind  20.47  3.0000000 10.970320  7.971595 0.028356308
## 20    4  5 nvDh  23.47  0.9049988  6.997648  5.990857 0.003480503</code></pre>
<p>Here, the first call returns the estimated assortments for both
assortment specifications, the tree order inside the resulting object is
clear: tree 1 uses Az=10 and tree 2 uses Az=7. In the second call, the
order is the same, although this is not as clear as in the first
example.</p>
</div>
</div>
<div id="more-advanced-specification-of-trees" class="section level3">
<h3>more advanced specification of trees</h3>
<p>As shown, a tree is specified by its species code, its dbh and
height. If done so, this assumes a predefined diameter in 30% of tree
height, which in turn defines the taper form or the relation between
diameter in 30% and 5% of the tree height. But easily, this can be
changed: the BWI-equivalent taper form can be specified using H2=50. The
D2 and H2 parameter can take a very flexible parameterisation being
diameter and heights but also quantiles of the q03-distribution (H2) or
the q03-parameter itself (D2). q03 is the quotient of diameter in 30% of
three height and in 5% of tree height. Hence, quite a variety of taper
forms can be represented. All BDAT-functions respond sensitively to this
fourth parameter.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">buildTree</span>(<span class="at">tree =</span> <span class="fu">list</span>(<span class="at">spp=</span><span class="dv">1</span>, <span class="at">D1=</span><span class="dv">30</span>, <span class="at">H=</span><span class="dv">27</span>, <span class="at">H2=</span><span class="fu">c</span>(<span class="dv">30</span>, <span class="dv">50</span>, <span class="dv">99</span>, <span class="dv">0</span>), </span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>                              <span class="at">D2=</span><span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="sc">-</span><span class="fl">0.8</span>), <span class="at">Hx=</span><span class="fl">0.3</span><span class="sc">*</span><span class="dv">27</span>))</span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a><span class="fu">str</span>(tree)</span></code></pre></div>
<pre><code>## Classes &#39;datBDAT&#39; and &#39;data.frame&#39;:  4 obs. of  7 variables:
##  $ spp: num  1 1 1 1
##  $ D1 : num  30 30 30 30
##  $ H  : num  27 27 27 27
##  $ H2 : num  30 50 99 0
##  $ D2 : num  0 0 0 -0.8
##  $ Hx : num  8.1 8.1 8.1 8.1
##  $ H1 : num  1.3 1.3 1.3 1.3</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="fu">getDiameter</span>(tree) <span class="co"># Hx specified beforehand being 30% of tree height</span></span></code></pre></div>
<pre><code>## [1] 23.19664 24.00090 27.59044 23.84774</code></pre>
<p>With the getForm-function, one can specify trees mimicking the mean
sample trees from different inventories. This function returns the
expected q03 of a given diameter-height-class, here of dbh=30 and
h=27:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="fu">getForm</span>(tree[<span class="dv">1</span>,], <span class="at">inv=</span><span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span></code></pre></div>
<pre><code>## [1] 0.8049681 0.7996023 0.7913954 0.8107125</code></pre>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
